"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const affReader_1 = require("./affReader");
const gensequence_1 = require("gensequence");
const fs = require("fs-extra");
const defaultEncoding = 'UTF-8';
class IterableHunspellReader {
    constructor(src) {
        this.src = src;
        this.aff = src.aff;
    }
    get dic() {
        return this.src.dic;
    }
    /**
     * @internal
     */
    dicWordsSeq() {
        return gensequence_1.genSequence(this.src.dic)
            .map(line => {
            const [word, rules] = line.split('/', 2);
            return { word, rules, prefixes: [], suffixes: [] };
        });
    }
    /**
     * iterates through the root words of the dictionary
     */
    iterateRootWords() {
        return this.seqRootWords();
    }
    iterateWords() {
        return this.seqWords();
    }
    [Symbol.iterator]() { return this.seqWords(); }
    seqAffWords(tapPreApplyRules) {
        const seq = gensequence_1.genSequence(this.src.dic);
        const dicWords = tapPreApplyRules ? seq.map(a => (tapPreApplyRules(a), a)) : seq;
        return dicWords
            .filter(a => !!a.trim())
            .concatMap(dicWord => this.aff.applyRulesToDicEntry(dicWord));
    }
    /**
     * @internal
     */
    seqWords() {
        return this.seqAffWords().map(w => w.word);
    }
    /**
     * @internal
     */
    seqRootWords() {
        return this.dicWordsSeq().map(w => w.word);
    }
    static createFromFiles(affFile, dicFile) {
        return __awaiter(this, void 0, void 0, function* () {
            const aff = yield affReader_1.parseAffFileToAff(affFile);
            const dicFileContent = yield fs.readFile(dicFile, aff.affInfo.SET || defaultEncoding);
            const dic = dicFileContent.split('\n')
                .slice(1) // The first entry is the count of entries.
                .filter(line => !!line);
            return new IterableHunspellReader({ aff, dic });
        });
    }
}
exports.IterableHunspellReader = IterableHunspellReader;
//# sourceMappingURL=IterableHunspellReader.js.map
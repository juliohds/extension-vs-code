#!/usr/bin/env node
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const commander = require("commander");
const IterableHunspellReader_1 = require("./IterableHunspellReader");
const fs = require("fs-extra");
const util_1 = require("./util");
const gensequence_1 = require("gensequence");
const aff_1 = require("./aff");
const iterableToStream_1 = require("./iterableToStream");
const uniqueHistorySize = 500000;
const packageInfo = require('../package.json');
const version = packageInfo['version'];
let displayHelp = true;
let logStream = process.stderr;
commander
    .version(version);
commander
    .command('words <hunspell_dic_file>')
    .option('-o, --output <file>', 'output file - defaults to stdout')
    .option('-s, --sort', 'sort the list of words')
    .option('-u, --unique', 'make sure the words are unique.')
    .option('-l, --lower_case', 'output in lower case')
    .option('-T, --no-transform', 'Do not apply the prefix and suffix transforms.  Root words only.')
    .option('-x, --infix', 'Return words with prefix / suffix breaks. ex: "un<do>ing"')
    .option('-r, --rules', 'Append rules used to generate word.')
    .option('-p, --progress', 'Show progress.')
    .description('Output all the words in the <hunspell.dic> file.')
    .action(action);
commander.parse(process.argv);
if (displayHelp) {
    commander.help();
}
function notify(message, newLine = true) {
    message = message + (newLine ? '\n' : '');
    logStream.write(message, 'utf-8');
}
function yesNo(value) {
    return value ? 'Yes' : 'No';
}
function affWordToInfix(aff) {
    return Object.assign({}, aff, { word: aff.prefix + '<' + aff.base + '>' + aff.suffix });
}
function mapWord(map) {
    return (aff) => (Object.assign({}, aff, { word: map(aff.word) }));
}
function appendRules(aff) {
    return Object.assign({}, aff, { word: aff.word + '\t[' + aff.rulesApplied + ' ]\t' + '(' + aff.dic + ')' });
}
function writeSeqToFile(seq, outFile) {
    return new Promise((resolve, reject) => {
        let resolved = false;
        const out = outFile ? fs.createWriteStream(outFile) : process.stdout;
        const bufferedSeq = gensequence_1.genSequence(util_1.batch(seq, 500)).map(batch => batch.join(''));
        const dataStream = iterableToStream_1.iterableToStream(bufferedSeq);
        const fileStream = dataStream.pipe(out);
        const endEvents = ['finish', 'close', 'end'];
        function resolvePromise() {
            if (!resolved) {
                resolved = true;
                resolve();
            }
        }
        const endHandler = () => {
            cleanupStreams();
            setTimeout(resolvePromise, 10);
        };
        const errorHandler = (e) => {
            cleanupStreams();
            reject(e);
        };
        listenToStreams();
        function listenToStreams() {
            endEvents.forEach(event => fileStream.addListener(event, endHandler));
            fileStream.addListener('error', errorHandler);
            dataStream.addListener('end', endHandler);
        }
        function cleanupStreams() {
            endEvents.forEach(event => fileStream.removeListener(event, endHandler));
            fileStream.removeListener('error', errorHandler);
            dataStream.removeListener('end', endHandler);
        }
    });
}
function action(hunspellDicFilename, options) {
    return actionPrime(hunspellDicFilename, options).catch((reason) => {
        if (reason.code === 'EPIPE') {
            return;
        }
        console.error(reason);
    });
}
function actionPrime(hunspellDicFilename, options) {
    return __awaiter(this, void 0, void 0, function* () {
        displayHelp = false;
        const { sort = false, unique = false, output: outputFile, lower_case: lowerCase = false, transform = true, infix = false, rules = false, progress: showProgress = false, } = options;
        logStream = outputFile ? process.stdout : process.stderr;
        const log = notify;
        log('Write words');
        log(`Sort: ${yesNo(sort)}`);
        log(`Unique: ${yesNo(unique)}`);
        const baseFile = hunspellDicFilename.replace(/\.(dic|aff)$/, '');
        const dicFile = baseFile + '.dic';
        const affFile = baseFile + '.aff';
        log(`Dic file: ${dicFile}`);
        log(`Aff file: ${affFile}`);
        log(`Generating Words...`);
        const reader = yield IterableHunspellReader_1.IterableHunspellReader.createFromFiles(affFile, dicFile);
        const transformers = [];
        if (infix) {
            transformers.push(affWordToInfix);
        }
        if (lowerCase) {
            transformers.push(mapWord(a => a.toLowerCase()));
        }
        if (rules) {
            transformers.push(appendRules);
        }
        transformers.push(mapWord(a => a.trim()));
        const dicSize = reader.dic.length;
        let current = 0;
        const calcProgress = () => '\r' + current + ' / ' + dicSize;
        const reportProgressRate = 253;
        const callback = showProgress
            ? () => {
                current++;
                !(current % reportProgressRate) && process.stderr.write(calcProgress(), 'UTF-8');
            }
            : () => { };
        const seqWords = transform ? reader.seqAffWords(callback) : reader.seqRootWords().map(aff_1.asAffWord);
        const filterUnique = unique ? util_1.uniqueFilter(uniqueHistorySize, (aff) => aff.word) : (_) => true;
        const applyTransformers = (aff) => transformers.reduce((aff, fn) => fn(aff), aff);
        const words = seqWords
            .map(applyTransformers)
            .filter(filterUnique)
            .filter(a => !!a.word)
            .map(a => a.word + '\n');
        if (sort) {
            log('Sorting...');
            const data = words.toArray().sort().join('');
            const fd = outputFile ? fs.openSync(outputFile, 'w') : 1;
            fs.writeSync(fd, data);
        }
        else {
            yield writeSeqToFile(words, outputFile);
        }
        if (showProgress) {
            console.error(calcProgress());
        }
        log('Done.');
    });
}
//# sourceMappingURL=app.js.map